package hugerSingleton;

/**
 * @Author jiajiao
 * @Date 2019/6/28 10:27
 * 饿汉式单例：不管用不用先创建实例
 * 缺点：耗费了资源
 * 问题1： static变量(静态成员变量)跟static方法块有什么区别？
 *
 * 静态成员变量值是所有类的实例共享的,所以调用的时候只需要  类名.属性名  就可调用（也只能这样调用），
 * 而非静态成员变量的值是各个实例私有的，所以调用的时候必须是先有具体的类的实例，然后通过实例名来调用。
 * 也就是说，static修饰的成员，大家用的时候都用的一个东西，一个人改动后，大家的都变了。而非static 修饰的成员是个人私有的，允许自己修改，每个人的都不一样。
 *
 * 所以在编码中，我们一般为static 变量加一个final，就是为了变量的一致性，不允许某个实例对它进行修改。
 * 这也解释了为什么不能在静态的方法中调用非静态的成员（变量或方法），因为静态方法不需要实例化就可调用，
 * 如果此时调用非静态的成员，不能确定类是否已被实例化，被调用的成员是否存在（静态成员是在类被实例化，创建具体对象时才分配空间）。
 * 而静态成员在类加载完成的时候就已经分配完空间，所以实际存在，可以被static方法调用。
 * 从生命周期上看：
 * 静态成员：  在类加载的时候，类加载完成，就分配完空间；直到类被卸载时空间被回收
 * 非静态成员： 创建对象的时候分配空间； 对象变为垃圾空间被回收的时候被销毁
 *
 * static方法块: 随着类的加载而执行，而且只执行一次
 *
 *
 *
 *具体的区别应该往堆栈方向上考虑内存的区别，用法上应该没有区别（自己的猜想，没有考证）
 *
 *
 *
 * 问题2： 私有变量instance为什么要加final关键字？
 *
 * 声明为final的变量，必须在类加载完成时已经赋值， 是什么意思呢？
 * 就是，如果你是final非static成员，必须在构造器、代码块、或者直接定义赋值；
 * 如果是final static 成员变量，必须直接赋值 或者在 静态代码块中赋值。
 * 然而直接赋值 或 静态代码块中赋值 就变成饿汉模式了，所以懒汉模式中，不能用final修饰

 * 问题3： 如何保证线程安全？-- 饿汉式单例是线程安全的，因为所有操作都是原子操作（不考虑序列化跟反射的情况下）
 */
public class HungerSingleton {

    // 为什么加final关键字? 因为反射可能会改变这个属性的值
    private static final HungerSingleton INSTANCE = new HungerSingleton();

    // 单例的前提就是构造函数私有化，不然谁都可以new对象
    private HungerSingleton() {

    }

    // 为什么是static? 因为要提供对外的获取实例的方法，由于构造函数已经私有化了，所以用static，直接访问对象的方法而无需先创建对象
    public static HungerSingleton getInstance(){
        return INSTANCE;
    }
}
